{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MongoDB Python Developer Path","text":""},{"location":"#description","title":"\ud83d\udc40 Description","text":"<p>This repository contains my notes of the MongoDB Python Developer Path. This course aims to prepare students to obtain the MongoDB Associate Developer Exam.</p> <p>This learning path contains a series of courses to teach MongoDB skills. In this path, you\u2019ll learn the basics of building modern applications with Python, using MongoDB as your database.</p>"},{"location":"BSON/BSON/","title":"BSON","text":"<ul> <li>Binary representation of JSON</li> <li>Optimized for speed and secutiry</li> <li>Prevents JSON injections</li> <li>Adds metadata</li> <li>Adds new types</li> </ul>"},{"location":"BSON/BSON/#core-types","title":"Core Types","text":"<ol> <li>String: Stores text data (UTF-8 encoded).</li> <li>Integer: Supports <code>int32</code> and <code>int64</code>.</li> <li>Double: 64-bit floating-point values.</li> <li>Boolean: <code>true</code> or <code>false</code>.</li> <li>Null: Represents a null value.</li> <li>Array: An ordered list of values.</li> <li>Embedded Document: Objects or nested documents.</li> </ol>"},{"location":"BSON/BSON/#specialized-types","title":"Specialized Types","text":"<ol> <li>ObjectId: 12-byte unique identifier.</li> <li>Date: Milliseconds since Unix epoch.</li> <li>Binary Data: Stores binary-encoded data like images.</li> <li>Regular Expression: For pattern matching.</li> <li>Decimal128: High-precision decimal for exact numeric operations.</li> <li>Timestamp: Special value for internal MongoDB usage.</li> <li>JavaScript with Scope: Stores JavaScript code with a scope.</li> </ol>"},{"location":"Model_Design/Analysis/","title":"Analysis","text":""},{"location":"Model_Design/Analysis/#schema-design-analysis","title":"\ud83d\udccc Schema Design Analysis","text":""},{"location":"Model_Design/Analysis/#1-identify-quantify-data-needs","title":"1\ufe0f\u20e3 Identify &amp; Quantify Data Needs","text":"<ul> <li>Define items and quantify them (size, frequency of access).</li> <li>Identify application read and write patterns.</li> <li>Quantify read/write frequency and determine the most common operations.</li> <li>Design schema optimized for frequent operations.</li> </ul>"},{"location":"Model_Design/Analysis/#2-identify-relationships-between-objects","title":"2\ufe0f\u20e3 Identify Relationships Between Objects","text":"<ul> <li>One-to-One </li> <li>One-to-Many </li> <li>Many-to-Many </li> </ul>"},{"location":"Model_Design/Analysis/#3-embedding-vs-references","title":"3\ufe0f\u20e3 Embedding vs. References","text":""},{"location":"Model_Design/Analysis/#key-considerations","title":"\ud83d\udccd Key Considerations","text":"<p>\u2705 Embedding \u2192 Store data together for efficiency. \u2705 Referencing \u2192 Normalize data for scalability and flexibility.</p> <ul> <li>Data that is accessed together should be stored together.</li> <li>Is the app read-heavy or write-heavy? <ul> <li>Read-heavy \u2192 Consider embedding.  </li> <li>Write-heavy \u2192 Consider referencing to avoid document growth issues.</li> </ul> </li> </ul>"},{"location":"Model_Design/Analysis/#when-to-embed","title":"\ud83d\udccc When to Embed?","text":"<p>\u2705 Use embedding when: - Simplicity is preferred. - There is a \"has-a\" or \"contains\" relationship. - Data is frequently retrieved together. - Updates should be atomic. - Minimal data duplication is required. - The document size is manageable (MongoDB 16MB limit). - Child cannot exist without the parent.</p> <p>\u274c Avoid embedding if: - Large amounts of embedded data cause document bloat. - Data duplication makes updates hard to manage. - Children can exist independently (use references instead).</p>"},{"location":"Model_Design/Analysis/#one-to-one-relationships","title":"\ud83d\udccc One-to-One Relationships","text":""},{"location":"Model_Design/Analysis/#when-to-embed_1","title":"\u2705 When to Embed?","text":"<ul> <li>If both entities are always queried together.</li> <li>Example: User Profile \u2192 User Settings (single document).</li> </ul> <pre><code>{\n  \"_id\": ObjectId(\"123\"),\n  \"name\": \"John Doe\",\n  \"settings\": {\n    \"theme\": \"dark\",\n    \"notifications\": true\n  }\n}\n</code></pre>"},{"location":"Model_Design/Analysis/#when-to-reference","title":"\u2705 When to Reference?","text":"<ul> <li>When the child object may exist independently.</li> <li>Types of referencing:<ul> <li>One object has a foreign key of the other.The most accessed document should store the foreign key.</li> <li>Both reference each other with foreign keys.</li> </ul> </li> </ul> <p><pre><code>{\n  \"_id\": ObjectId(\"123\"),\n  \"name\": \"John Doe\",\n  \"profile_id\": ObjectId(\"456\")\n}\n</code></pre> <pre><code>{\n  \"_id\": ObjectId(\"456\"),\n  \"user_id\": ObjectId(\"123\"),\n  \"bio\": \"Software Developer\"\n}\n</code></pre></p>"},{"location":"Model_Design/Analysis/#one-to-many-relationships","title":"\ud83d\udccc One-to-Many Relationships","text":""},{"location":"Model_Design/Analysis/#when-to-embed_2","title":"\u2705 When to Embed?","text":"<ul> <li>Few child documents per parent.</li> <li>Data is always queried together.</li> <li>Example: Blog \u2192 Comments.</li> </ul> <pre><code>{\n  \"_id\": ObjectId(\"123\"),\n  \"title\": \"MongoDB Best Practices\",\n  \"comments\": [\n    { \"user\": \"Alice\", \"text\": \"Great article!\" },\n    { \"user\": \"Bob\", \"text\": \"Thanks for sharing.\" }\n  ]\n}\n</code></pre>"},{"location":"Model_Design/Analysis/#when-to-reference_1","title":"\u2705 When to Reference?","text":"<ul> <li>If the child collection grows indefinitely.</li> <li>Types of referencing:<ul> <li>Parent or children has the foreign key of each other.</li> <li>Both parent and children have foreign key.</li> </ul> </li> <li>Example: User \u2192 Orders.</li> </ul> <pre><code>{\n  \"_id\": ObjectId(\"123\"),\n  \"name\": \"John Doe\",\n  \"orders\": [ ObjectId(\"order1\"), ObjectId(\"order2\") ]\n}\n</code></pre> <pre><code>{\n  \"_id\": ObjectId(\"order1\"),\n  ...\n}\n</code></pre>"},{"location":"Model_Design/Analysis/#many-to-many-relationships","title":"\ud83d\udccc Many-to-Many Relationships","text":""},{"location":"Model_Design/Analysis/#when-to-embed_3","title":"\u2705 When to Embed?","text":"<ul> <li>Data duplication is acceptable.</li> <li>Example: Author \u2192 Books (Embedded List).</li> </ul> <pre><code>{\n  \"_id\": ObjectId(\"123\"),\n  \"name\": \"J.K. Rowling\",\n  \"books\": [\n    { \"title\": \"Harry Potter 1\" },\n    { \"title\": \"Harry Potter 2\" }\n  ]\n}\n</code></pre>"},{"location":"Model_Design/Analysis/#when-to-reference_2","title":"\u2705 When to Reference?","text":"<ul> <li>Avoid bidirectional references (expensive joins).</li> <li>Use an intermediate \"junction\" collection.</li> <li>Example: Students &amp; Courses (Many-to-Many Reference).</li> </ul> <pre><code>// Students Collection\n{\n  \"_id\": ObjectId(\"s1\"),\n  \"name\": \"Alice\",\n  \"enrolled_courses\": [ ObjectId(\"c1\"), ObjectId(\"c2\") ]\n}\n\n// Courses Collection\n{\n  \"_id\": ObjectId(\"c1\"),\n  \"title\": \"MongoDB 101\",\n  \"students_enrolled\": [ ObjectId(\"s1\"), ObjectId(\"s2\") ]\n}\n\n// Junction Collection (Enrollment)\n{\n  \"_id\": ObjectId(\"e1\"),\n  \"student_id\": ObjectId(\"s1\"),\n  \"course_id\": ObjectId(\"c1\"),\n  \"enrollment_date\": \"2024-03-08\"\n}\n</code></pre>"},{"location":"Model_Design/Analysis/#final-takeaways","title":"\ud83d\udccc Final Takeaways","text":"Use Case Embedding \u2705 Referencing \u2705 One-to-One \u2714\ufe0f If always accessed together \u2714\ufe0f If separate access is needed One-to-Many \u2714\ufe0f If small &amp; accessed together \u2714\ufe0f If array is unbounded Many-to-Many \u274c Not recommended \u2714\ufe0f Use an intermediate collection"},{"location":"mongosh/Aggregation/","title":"Aggregation","text":"<pre><code>db.orders.aggregate([\n  { $match: { category: \"Stationery\" } },\n  { \n    $group: { \n      _id: null, \n      totalQuantity: { $sum: \"$quantity\" }, \n    } \n  }\n]);\n</code></pre> <p>We can get value of a field by using <code>$fieldName</code></p> <pre><code>db.collection.aggregate([\n  {\n    $set: {\n      defaultUsername: {\n        $concat: [\"$first_name\", \" \", \"$last_name\"]\n      }\n    }\n  }\n]);\n</code></pre>"},{"location":"mongosh/Aggregation/#match","title":"$match","text":"<p>Find documents that match certain condition.</p> <pre><code>{\n  $match: {\n     \"field_name\": \"value\"\n  }\n}\n</code></pre>"},{"location":"mongosh/Aggregation/#group","title":"$group","text":"<p>Group documents by a field name. It will return one document per unique key. The _id field specifies which field we're using to group the data.</p> <pre><code>{\n   $group: {\n      _id: \"$city\",\n      // group key\n      totalZips: { $count : { } }\n      // &lt;field&gt;: { &lt;accumulator&gt; : &lt;expression&gt; }\n   }\n}\n</code></pre>"},{"location":"mongosh/Aggregation/#sort","title":"$sort","text":"<p>Sort documents in ascending/descending order by fields.</p> <pre><code>{\n  $sort: {\n      \"field_name\": 1 // 1 for ascending, -1 for descending order\n  }\n}\n</code></pre>"},{"location":"mongosh/Aggregation/#limit","title":"$limit","text":"<p>Limit amount of returned documents.</p> <pre><code>{\n  $limit: 5\n}\n</code></pre>"},{"location":"mongosh/Aggregation/#project","title":"$project","text":"<p>Select fields for output document.</p> <pre><code>{\n  $project:{\n\n    field1:0, // do not include\n    field2:1, // include\n    field3: $field1\n\n  }\n\n}\n</code></pre>"},{"location":"mongosh/Aggregation/#set","title":"$set","text":"<p>Adds or modify fields on the pipeline.</p> <pre><code>{\n  $set: {\n      place: {\n          $concat:[\"$city\",\",\",\"$state\"]\n      },\n      pop:10000\n    }\n  }\n</code></pre>"},{"location":"mongosh/Aggregation/#count","title":"$count","text":"<p>Count documents in the pipeline. Returns a document with only one field with the name that we set with the count output of the pipeline.</p> <pre><code>{\n  $count:\"returnField\"\n}\n</code></pre>"},{"location":"mongosh/Aggregation/#out","title":"$out","text":"<p>Writes output documents of pipeline into another collection. Must be the last stage of the pipeline.</p>"},{"location":"mongosh/Aggregation/#using-same-database-as-the-aggregation-uses","title":"Using same database as the aggregation uses","text":"<pre><code>{\n  $out: \"new_collection\"\n}\n</code></pre>"},{"location":"mongosh/Aggregation/#other-database","title":"Other database","text":"<pre><code>{\n  $out: {db:\"new_collection\",coll:\"new_collection\"}\n}\n</code></pre>"},{"location":"mongosh/Bulk_Write/","title":"Bulk Write Operations","text":"<p>Allows to multiple write operations to be sent in a single query. Useful when handling high volume operations.</p> <pre><code>db.collection.bulkWrite(operations, options);\n</code></pre> <pre><code>db.products.bulkWrite([\n  {\n    insertOne: {\n      document: { _id: 1, name: \"Laptop\", price: 999, stock: 50 }\n    }\n  },\n  {\n    insertOne: {\n      document: { _id: 2, name: \"Mouse\", price: 25, stock: 150 }\n    }\n  },])\n</code></pre>"},{"location":"mongosh/Bulk_Write/#supported-operations","title":"Supported operations","text":"<ul> <li>insertOne: Inserts a single document.</li> <li>updateOne: Updates a single document.</li> <li>updateMany: Updates multiple documents.</li> <li>deleteOne: Deletes a single document.</li> <li>deleteMany: Deletes multiple documents.</li> <li>replaceOne: Replaces a document.</li> </ul>"},{"location":"mongosh/Connect/","title":"Connect","text":""},{"location":"mongosh/Connect/#docker","title":"Docker","text":"<pre><code>docker exec -it mongodb mongosh --username root --password root\n</code></pre>"},{"location":"mongosh/Connect/#list-databases","title":"List databases","text":"<pre><code>show dbs\n</code></pre>"},{"location":"mongosh/Connect/#select-database","title":"Select database","text":"<pre><code>use database_name\n</code></pre>"},{"location":"mongosh/Connect/#list-collections","title":"List collections","text":"<pre><code>show collections\n</code></pre>"},{"location":"mongosh/Delete/","title":"Delete Operations","text":""},{"location":"mongosh/Delete/#delete-one-document","title":"Delete One Document","text":"<pre><code>db.podcasts.deleteOne({ _id: Objectid(\"6282c9862acb966e76bbf20a\") })\n</code></pre>"},{"location":"mongosh/Delete/#delete-many-documents","title":"Delete Many Documents","text":"<pre><code>db.podcasts.deleteMany({category: \u201ccrime\u201d})\n</code></pre>"},{"location":"mongosh/Delete/#find-one-and-delete","title":"Find one and delete","text":"<pre><code>db.collection.findOneAndDelete({city : {$in : [\"CHICAGO\"] }})\n</code></pre>"},{"location":"mongosh/Find/","title":"Find Operations","text":""},{"location":"mongosh/Find/#find-documents","title":"Find documents","text":""},{"location":"mongosh/Find/#find-only-one-document","title":"Find only one document","text":"<pre><code>db.collection.findOne({_id:ObjectID(\"id\")})\n</code></pre>"},{"location":"mongosh/Find/#with-equality","title":"With equality","text":"<pre><code>db.collection.find({_id:ObjectID(\"id\")})\n</code></pre>"},{"location":"mongosh/Find/#with-in-operator","title":"With $in operator","text":"<pre><code>db.collection.find({city : {$in : [\"CHICAGO\"] }})\n</code></pre>"},{"location":"mongosh/Find/#finding-documents-by-using-comparison-operators","title":"Finding Documents by Using Comparison Operators","text":"<ul> <li><code>$gt</code> - Greater than</li> <li><code>$lt</code> - Less than</li> <li><code>$gte</code> - Greater or equal than </li> <li><code>$lte</code> - Less or equal than</li> </ul> <pre><code>db.sales.find({ \"items.price\": { $gt: 50}})\n</code></pre>"},{"location":"mongosh/Find/#quering-on-array-elements","title":"Quering on array elements","text":""},{"location":"mongosh/Find/#find-documents-with-an-array-that-contains-a-specified-value","title":"Find Documents with an Array That Contains a Specified Value","text":"<p>Matches any document where the products field is an array and \"InvestmentFund\" is an element in that array.</p> <pre><code>db.accounts.find({ products: \"InvestmentFund\"})\n</code></pre>"},{"location":"mongosh/Find/#find-a-document-using-elemmatch","title":"Find a Document using $elemMatch","text":"<p>Matches any document that contains a item in that field that validates all the conditions.</p> <pre><code>db.sales.find({\n  items: {\n    $elemMatch: { name: \"laptop\", price: { $gt: 800 }, quantity: { $gte: 1 } },\n  },\n})\n</code></pre>"},{"location":"mongosh/Find/#finding-documents-by-using-logical-operators","title":"Finding Documents by using Logical Operators","text":""},{"location":"mongosh/Find/#implicit-and","title":"Implicit $and","text":"<pre><code>db.routes.find({ \"airline.name\": \"Southwest Airlines\", stops: { $gte: 1 } })\n</code></pre>"},{"location":"mongosh/Find/#or","title":"$or","text":"<pre><code>db.routes.find({\n  $or: [{ dst_airport: \"SEA\" }, { src_airport: \"SEA\" }],\n})\n</code></pre>"},{"location":"mongosh/Find/#and","title":"$and","text":"<pre><code>db.routes.find({\n  $and: [\n    { $or: [{ dst_airport: \"SEA\" }, { src_airport: \"SEA\" }] },\n    { $or: [{ \"airline.name\": \"American Airlines\" }, { airplane: 320 }] },\n  ]\n})\n</code></pre>"},{"location":"mongosh/Indexes/","title":"Indexes","text":""},{"location":"mongosh/Indexes/#using-indexes-in-collections","title":"Using Indexes in Collections","text":""},{"location":"mongosh/Indexes/#benefits","title":"\u2705 Benefits","text":"<ul> <li>Improved reads by only checking documents that match the index, instead of checking every document.</li> </ul>"},{"location":"mongosh/Indexes/#drawbacks","title":"\u2757 Drawbacks","text":"<ul> <li>Performance on writes descend as indexes need to be updated.</li> <li>More storage to store indexes.</li> </ul>"},{"location":"mongosh/Indexes/#types-of-index","title":"Types of index","text":"<ul> <li>Single field: only one field is used as index.</li> <li>Compound: multiple fields of document are used as indexes.</li> <li>Multikey: index fields with an array key. llows for improved performance on checking attributes of objects inside an array. Example: given a student check if it has one grade that is less than 5. We can set grades as multikey index.</li> </ul>"},{"location":"mongosh/Indexes/#check-indexes-on-collection","title":"Check indexes on collection","text":"<p>Retrieve all indexes of a colelction.</p> <pre><code>db.customers.getIndexes()\n</code></pre>"},{"location":"mongosh/Indexes/#check-if-index-is-used-in-a-query","title":"Check if index is used in a query","text":"<p>Use <code>explain()</code> command before the query and if it shows <code>IXSCAN</code> on <code>FETCH</code> the query is using an index. It will also show which index is being used.</p> <pre><code>db.customers.explain().find({\n  birthdate: {\n    $gt:ISODate(\"1995-08-01\")\n    }\n  })\n</code></pre>"},{"location":"mongosh/Indexes/#creating-a-single-field-index","title":"Creating a Single Field Index","text":""},{"location":"mongosh/Indexes/#single-field-index-creation","title":"Single field index creation","text":"<p>We must set a value for the index key: 1/-1 for ascending, descending order respectively.</p> <pre><code>db.customers.createIndex({\n    birthdate: 1\n})\n</code></pre>"},{"location":"mongosh/Indexes/#single-field-unique-index-creation","title":"Single field unique index creation","text":"<p>If <code>unique</code> is set to true:</p> <ul> <li>Cannot create a document with a duplicated field value. It will throw an error upon insertion.</li> </ul> <pre><code>db.customers.createIndex({\n  email: 1\n},\n{\n  unique:true\n})\n</code></pre>"},{"location":"mongosh/Indexes/#creating-a-multikey-index","title":"Creating a Multikey Index","text":"<ul> <li>Only one array field for index.</li> </ul> <p>Given:</p> <pre><code>{   \n    id: ...,\n    accounts: [...]\n}\n</code></pre> <p>We create the index as:</p> <pre><code>db.customers.createIndex({\n  accounts: 1\n})\n</code></pre>"},{"location":"mongosh/Indexes/#working-with-compound-indexes","title":"Working with Compound Indexes","text":"<p>Can be turned into <code>multikey Index</code> if one index is a field with an array.</p> <pre><code>db.customers.createIndex({\n  active:1, \n  birthdate:-1,\n  name:1\n})\n</code></pre>"},{"location":"mongosh/Indexes/#order-of-fields-in-a-compound-index","title":"Order of Fields in a Compound Index","text":"<p>The order of the fields matters when creating the index and the sort order. It is recommended to list the fields in the following order: Equality, Sort, and Range.</p> <ul> <li>Equality: field/s that matches on a single field value in a query</li> <li>Sort: field/s that orders the results by in a query</li> <li>Range: field/s that the query filter in a range of valid values -&gt; $gte, etc. It doesnt mean .limit()</li> </ul> <pre><code>db.customers.find({\n  birthdate: {\n    $gte:ISODate(\"1977-01-01\")\n    },\n    active:true\n    }).sort({\n      birthdate:-1, \n      name:1\n      })\n</code></pre> <p>Here's an example of an efficient index for this query:</p> <pre><code>db.customers.createIndex({\n  active:1, \n  birthdate:-1,\n  name:1\n})\n</code></pre> <p>If were getting fields from a query and they're not used for sort or filter, we should include them at the end of the query for better performance</p>"},{"location":"mongosh/Indexes/#deleting-mongodb-indexes","title":"Deleting MongoDB Indexes","text":"<p>Removing redundant or unused indexes can be useful. Restoring an index is more costly than simply hiding it, so hiding indexes is recommended.</p>"},{"location":"mongosh/Indexes/#hide","title":"Hide","text":"<p>If not sure if the index is being used/</p> <pre><code>db.collection.hideIndex(&lt;index&gt;)\n</code></pre>"},{"location":"mongosh/Indexes/#delete","title":"Delete","text":"<p>An index for a field is redundant if the same field is on another multiple key index.</p> <p>Example: <code>keyA_1 and keyA_1_keyB_1</code>. We can remove the first index.</p>"},{"location":"mongosh/Indexes/#one","title":"One","text":"<pre><code>db.customers.dropIndex(\n  'active_1_birthdate_-1_name_1'\n)\n</code></pre>"},{"location":"mongosh/Indexes/#multiple","title":"Multiple","text":"<pre><code>db.collection.dropIndexes([\n  'index1name', 'index2name', 'index3name'\n  ])\n</code></pre>"},{"location":"mongosh/Indexes/#all","title":"All","text":"<pre><code>db.customers.dropIndexes()\n</code></pre>"},{"location":"mongosh/Insert/","title":"Insert Operations","text":""},{"location":"mongosh/Insert/#insert-one-document","title":"Insert one document","text":"<pre><code>db.collection.insertOne({\n  student_id: 654321,\n  products: [\n    {\n      type: \"exam\",\n      score: 90,\n    },\n    {\n      type: \"homework\",\n      score: 59,\n    },\n    {\n      type: \"quiz\",\n      score: 75,\n    },\n    {\n      type: \"homework\",\n      score: 88,\n    },\n  ],\n  class_id: 550,\n})\n</code></pre>"},{"location":"mongosh/Insert/#insert-many-documents","title":"Insert many documents","text":"<pre><code>db.collection.insertMany([{student_id: 654321},{student_id: 777,}])\n</code></pre>"},{"location":"mongosh/Lookup/","title":"MongoDB <code>$lookup</code> - Left Outer Join","text":""},{"location":"mongosh/Lookup/#overview","title":"Overview","text":"<p>The <code>$lookup</code> stage in MongoDB\u2019s aggregation pipeline performs a left outer join between two collections. This allows you to combine related documents from different collections based on a common field, similar to SQL joins.</p> <p>In this example, we retrieve an author and all the books written by that author.</p>"},{"location":"mongosh/Lookup/#sample-collections","title":"Sample Collections","text":""},{"location":"mongosh/Lookup/#authors_collection-main-collection","title":"<code>authors_collection</code> (Main Collection)","text":"<p>Each document represents an author: <pre><code>{\n    \"_id\": 2,\n    \"name\": \"J.K. Rowling\"\n}\n</code></pre></p>"},{"location":"mongosh/Lookup/#books_collection-joined-collection","title":"<code>books_collection</code> (Joined Collection)","text":"<p>Each document represents a book and contains an <code>author_id</code> field linking it to an author: <pre><code>{\n    \"_id\": 1,\n    \"author_id\": 2,\n    \"title\": \"Harry Potter\"\n}\n</code></pre></p>"},{"location":"mongosh/Lookup/#aggregation-query","title":"Aggregation Query","text":"<p>To retrieve an author and their books, use the following MongoDB aggregation pipeline:</p> <pre><code>db.authors_collection.aggregate([\n  {\n    $match: {\n      _id: 2 // Filter to get the author with _id: 2\n    },\n  },\n  {\n    $lookup: {\n      from: \"books_collection\",  // The collection to join (books)\n      localField: \"_id\",         // Field in authors_collection (_id)\n      foreignField: \"author_id\", // Field in books_collection (author_id)\n      as: \"books\"                // Output field where matched books will be stored\n    },\n  },\n]);\n</code></pre>"},{"location":"mongosh/Lookup/#expected-output","title":"Expected Output","text":"<p>If the author exists and has written books, the output will include the author\u2019s details along with a list of their books in the <code>\"books\"</code> array:</p> <pre><code>[\n  {\n    \"_id\": 2,\n    \"name\": \"J.K. Rowling\",\n    \"books\": [\n      { \"_id\": 1, \"author_id\": 2, \"title\": \"Harry Potter\" }\n    ]\n  }\n]\n</code></pre> <p>If no matching books are found, the <code>\"books\"</code> array will be empty (<code>[]</code>), ensuring that the author record is still returned.</p>"},{"location":"mongosh/Lookup/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Performs a left outer join \u2192 All authors are included, even if they have no books. \u2705 Combines documents using common fields (<code>_id</code> in <code>authors_collection</code> and <code>author_id</code> in <code>books_collection</code>). \u2705 Results are stored in an array (<code>as: \"books\"</code>) \u2192 If no books exist for an author, <code>\"books\": []</code>.  </p>"},{"location":"mongosh/Modifying_Query_Results/","title":"Modifying query results Operations","text":""},{"location":"mongosh/Modifying_Query_Results/#sorting-and-limiting-query-results","title":"Sorting and Limiting Query Results","text":""},{"location":"mongosh/Modifying_Query_Results/#sort","title":"Sort","text":"<p>We specify the query and then a field that contains the parameter to sort with the following flag:</p> <ul> <li>1: ascending order</li> <li>-1: descending order</li> </ul> <pre><code>db.collection.find(&lt;query&gt;).sort(&lt;sort&gt;)\n</code></pre> <pre><code>db.companies.find({ category_code: \"music\" }).sort({ name: 1,_id: 1 });\n</code></pre>"},{"location":"mongosh/Modifying_Query_Results/#limit","title":"Limit","text":"<p>We specify the maximum results we want to get from a query:</p> <pre><code>db.companies.find(&lt;query&gt;).limit(&lt;number&gt;)\n</code></pre> <pre><code>db.companies\n  .find({ category_code: \"music\" })\n  .sort({ number_of_employees: -1, _id: 1 })\n  .limit(3);\n</code></pre>"},{"location":"mongosh/Modifying_Query_Results/#skip","title":"Skip","text":"<p>Skips certain number of documents in a query result. Useful por pagination.</p> <p><pre><code>db.products.find().skip(2);\n</code></pre> If the previous query is runned with the followind dataset:</p> <pre><code>[\n  { _id: 1, name: \"Laptop\", price: 1000 },\n  { _id: 2, name: \"Mouse\", price: 20 },\n  { _id: 3, name: \"Keyboard\", price: 50 },\n  { _id: 4, name: \"Monitor\", price: 300 },\n  { _id: 5, name: \"Headphones\", price: 80 }\n]\n</code></pre> <p>We will get:</p> <pre><code>[\n  { _id: 3, name: \"Keyboard\", price: 50 },\n  { _id: 4, name: \"Monitor\", price: 300 },\n  { _id: 5, name: \"Headphones\", price: 80 }\n]\n</code></pre>"},{"location":"mongosh/Modifying_Query_Results/#returning-specific-data-from-a-query","title":"Returning Specific Data from a Query","text":""},{"location":"mongosh/Modifying_Query_Results/#projections","title":"Projections","text":"<p>Projections allow us to determine which fields we want to retrieve from a query result. We cannot exclude and include fields in the same projection, except if the <code>_id</code> field.</p> <pre><code>db.collection.find( &lt;query&gt;, &lt;projection&gt; )\n</code></pre>"},{"location":"mongosh/Modifying_Query_Results/#include","title":"Include","text":"<p>We can include fields in the result using a projection <code>{field_name:1}</code>:</p> <pre><code>db.inspections.find(\n  { sector: \"Restaurant - 818\" },\n  { business_name: 1, result: 1 }\n)\n</code></pre>"},{"location":"mongosh/Modifying_Query_Results/#exclude","title":"Exclude","text":"<p>We can exclude fields in the result using a projection <code>{field_name:0}</code>:</p> <pre><code>db.inspections.find(\n  { result: { $in: [\"Pass\", \"Warning\"] } },\n  { date: 0, \"address.zip\": 0 }\n)\n</code></pre>"},{"location":"mongosh/Modifying_Query_Results/#counting-documents-in-a-collection","title":"Counting Documents in a Collection","text":"<p>Count number of documents that match a specify query:</p> <pre><code>db.trips.countDocuments({ tripduration: { $gt: 120 }, usertype: \"Subscriber\" })\n</code></pre>"},{"location":"mongosh/Operators/","title":"Operators","text":""},{"location":"mongosh/Operators/#expr","title":"$expr","text":"<p>Allows comparisons between fields of the same document.</p> <pre><code>{\n  \"$expr\": {\n    \"&lt;aggregationOperator&gt;\": [ \"&lt;field1&gt;\", \"&lt;field2&gt;\" ]\n  }\n}\n</code></pre>"},{"location":"mongosh/Operators/#exists","title":"$exists","text":"<p>Checks if a field exists</p> <pre><code>{\n  \"field\":{\"$exists\" : true}\n}\n</code></pre>"},{"location":"mongosh/Operators/#rename","title":"$rename","text":"<p>Rename a field</p> <pre><code>{\n  \"$rename\" : {\"old_name\":\"new_name\"}\n}\n</code></pre>"},{"location":"mongosh/Operators/#set","title":"$set","text":"<p>Sets a field</p> <pre><code>{\n  \"$set\" : {\"field\":\"value\",\"field2\":\"value\"}\n}\n</code></pre>"},{"location":"mongosh/Operators/#unset","title":"$unset","text":"<p>Removes a field</p> <pre><code>{\n  \"$unset\" : [\"field1\",\"field2\"]\n}\n</code></pre>"},{"location":"mongosh/Schema_Validation/","title":"Schema validation","text":"<p>MongoDB schema validation allows us to enforce rules on documents within a collection, ensuring data consistency.</p> <ul> <li>Skipping validation during the early stages of development can speed up the process..</li> <li>Once our data model is established, we can enforce validations to ensure data consistency.</li> </ul>"},{"location":"mongosh/Schema_Validation/#validator","title":"Validator","text":"<p>Based on json schema.</p>"},{"location":"mongosh/Schema_Validation/#applied-validator-on-creation","title":"Applied validator on creation","text":"<pre><code>db.createCollection(\"sales\", {\n    validator: {\n      \"$and\": [\n        {\n          \"$expr\": {\n            \"$lt\": [\"$items.discountedPrice\", \"$items.price\"]\n          }\n        },\n        {\n          \"$jsonSchema\": {\n            \"properties\": {\n              \"items\": { \"bsonType\": \"array\" }\n            }\n           }\n         }\n       ]\n     }\n   }\n )\n</code></pre>"},{"location":"mongosh/Schema_Validation/#applied-validator-after-creation","title":"Applied validator after creation","text":"<p>Objects created before enforcing the validator won't be affected by new validations.</p> <pre><code>db.runCommand({\n    collMod: \"reviews\", // collection to modify\n    validator: bookstore_reviews_default, // validator specified in the example below\n    validationLevel: \"strict\",\n    validationAction: \"error\", // rejects operation\n});\n</code></pre>"},{"location":"mongosh/Schema_Validation/#check-non-validated-documents","title":"Check non validated documents","text":"<pre><code>db.collection.find( { $nor: [ validator ] } )\n</code></pre>"},{"location":"mongosh/Schema_Validation/#validation-mode","title":"Validation mode","text":"<p>Specifies when rules are applied.</p> <ul> <li>Strict: rejects any document that do not match the validation.</li> <li>Moderate: only validate fields that match the schema but not extra fields.</li> </ul>"},{"location":"mongosh/Schema_Validation/#validation-actions","title":"Validation actions","text":"<p>What needs to be done after validation fails.</p> <ul> <li>Warn. Logs a warning but the operation is resolved.</li> <li>Error. Rejects operation.</li> </ul>"},{"location":"mongosh/Schema_Validation/#validator-example","title":"Validator example","text":"<pre><code>const bookstore_reviews_default = {\n    $jsonSchema:{\n        bsonType: \"object\", // type of the field\n        required: [\u201c_id\u201d, \"review_id\", \"user_id\", \"timestamp\", \"review\", \"rating\"], // required fields\n        additionalProperties: false, // can't add new properties that are not listed\n        properties: {\n            _id: { bsonType: \"objectId\" },\n            review_id: { bsonType: \"string\" },\n            user_id: { bsonType: \"string\" },\n            timestamp: { bsonType: \"date\" },\n            review: { bsonType: \"string\" },\n            rating: {\n                bsonType: \"int\",\n                minimum: 0,\n                maximum: 5,\n            },\n            comments: {\n                bsonType: \"array\",\n                maxItems: 3,\n                items: {\n                    bsonType: \"object\",\n                },\n            },\n        },\n    }\n};\n</code></pre>"},{"location":"mongosh/Update/","title":"Update Operations","text":""},{"location":"mongosh/Update/#replacing-a-document","title":"Replacing a Document","text":"<p>Select the document to replace and insert all the new fields that it will have. The fields not inserted will stay the same. In the example <code>_id</code> will not change in the new document. It only works with one document, there's no <code>replace</code> or <code>replaceMany</code> method.</p> <pre><code>db.books.replaceOne(\n  {\n    _id: ObjectId(\"6282afeb441a74a98dbbec4e\"),\n  },\n  {\n    title: \"Data Science Fundamentals for Python and MongoDB\",\n    isbn: \"1484235967\",\n    publishedDate: new Date(\"2018-5-10\"),\n    thumbnailUrl:\n      \"https://m.media-amazon.com/images/I/71opmUBc2wL._AC_UY218_.jpg\",\n    authors: [\"David Paper\"],\n    categories: [\"Data Science\"],\n  }\n)\n</code></pre>"},{"location":"mongosh/Update/#updating-documents-by-using-updateone","title":"Updating Documents by Using updateOne()","text":"<p>The <code>updateOne()</code> method accepts a filter document, an update document, and an optional options object. MongoDB provides update operators and options to help you update documents. In this section, we'll cover three of them: <code>$set</code>, <code>upsert</code>, and <code>$push</code>.</p>"},{"location":"mongosh/Update/#set","title":"$set","text":"<p>Replaces field with a value</p> <pre><code>db.podcasts.updateOne(\n  {\n    _id: ObjectId(\"5e8f8f8f8f8f8f8f8f8f8f8\"),\n  },\n\n  {\n    $set: {\n      subscribers: 98562,\n    },\n  }\n)\n</code></pre>"},{"location":"mongosh/Update/#upsert","title":"$upsert","text":"<p>If no document matches the filter a new one will be created</p> <pre><code>db.podcasts.updateOne(\n  { title: \"The Developer Hub\" },\n  { $set: { topics: [\"databases\", \"MongoDB\"] } },\n  { upsert: true }\n)\n</code></pre>"},{"location":"mongosh/Update/#push","title":"$push","text":"<p>Add item to an array</p> <pre><code>db.podcasts.updateOne(\n  { _id: ObjectId(\"5e8f8f8f8f8f8f8f8f8f8f8\") },\n  { $push: { hosts: \"Nic Raboy\" } }\n)\n</code></pre>"},{"location":"mongosh/Update/#unset","title":"$unset","text":"<p>Deletes a field from a document</p> <pre><code>db.users.update(\n  { name: \"Alice\" },\n  { $unset: { status: \"\" } }\n)\n</code></pre>"},{"location":"mongosh/Update/#max","title":"$max","text":"<p>Makes the update only if the field value is higher than another one. It will update score field to 90 only if it's higher than the existing field value.</p> <pre><code>db.users.update(\n  { name: \"Alice\" },\n  { $max: { score: 90 } }\n)\n</code></pre>"},{"location":"mongosh/Update/#updating-documents-by-using-findandmodify","title":"Updating Documents by Using findAndModify()","text":"<p>New option is specified if want to return the modified document. This query is useful because:</p> <ul> <li>Only one query instead of two</li> <li>Thread protecting if the field changed while finding and modifying the document. A value could be modified between our queries.</li> </ul> <pre><code>db.podcasts.findAndModify({\n  query: { _id: ObjectId(\"6261a92dfee1ff300dc80bf1\") },\n  update: { $inc: { subscribers: 1 } },\n  new: true,\n})\n</code></pre>"},{"location":"mongosh/Update/#updating-documents-by-using-updatemany","title":"Updating Documents by Using updateMany()","text":"<ul> <li>There's no rollback if some document update fails</li> </ul> <pre><code>db.books.updateMany(\n  { publishedDate: { $lt: new Date(\"2019-01-01\") } },\n  { $set: { status: \"LEGACY\" } }\n)\n</code></pre>"},{"location":"python/Aggregation/","title":"Aggregation","text":"<pre><code># Create an aggegation pipeline using 'stage_match_balance' and 'stage_group_account_type'.\npipeline = [\n    select_by_balance,\n    separate_by_account_calculate_avg_balance,\n]\n\nresults = accounts_collection.aggregate(pipeline)\n</code></pre>"},{"location":"python/Aggregation/#match","title":"Match","text":"<pre><code>select_by_balance = {\"$match\": {\"balance\": {\"$lt\": 1000}}}\n</code></pre>"},{"location":"python/Aggregation/#group","title":"Group","text":"<pre><code>separate_by_account_calculate_avg_balance = {\n    \"$group\": {\"_id\": \"$account_type\", \"avg_balance\": {\"$avg\": \"$balance\"}}\n}\n</code></pre>"},{"location":"python/Aggregation/#sort","title":"Sort","text":"<pre><code># Organize documents in order from highest balance to lowest.\norganize_by_original_balance = {\"$sort\": {\"balance\": -1}}\n</code></pre>"},{"location":"python/Aggregation/#project","title":"Project","text":"<pre><code># Return only the account type &amp; balance fields, plus a new field containing balance in Great British Pounds (GBP).\nreturn_specified_fields = {\n    \"$project\": {\n        \"account_type\": 1,\n        \"balance\": 1,\n        \"gbp_balance\": {\"$divide\": [\"$balance\", conversion_rate_usd_to_gbp]},\n        \"_id\": 0,\n    }\n}\n</code></pre>"},{"location":"python/Bulk_Write/","title":"Bulk Write Operation","text":"<pre><code>requests = [\n    InsertOne({\"name\": \"John\", \"age\": 30}),\n    InsertOne({\"name\": \"Alice\", \"age\": 25}),\n    UpdateOne({\"name\": \"John\"}, {\"$set\": {\"age\": 31}}),\n    DeleteOne({\"name\": \"Alice\"})\n]\n\ntry:\n    result = collection.bulk_write(requests)\n    print(f\"Bulk write result: {result.bulk_api_result}\")\nexcept BulkWriteError as bwe:\n    print(f\"Bulk write error: {bwe.details}\")\n</code></pre>"},{"location":"python/Connection/","title":"Database Connection","text":""},{"location":"python/Connection/#uri-format","title":"URI format","text":""},{"location":"python/Connection/#localhost","title":"Localhost","text":"<pre><code>MONGODB_URI= mongodb://root:root@127.0.0.1:27017/\n</code></pre>"},{"location":"python/Connection/#atlas","title":"Atlas","text":"<pre><code>MONGODB_URI= mongodb+srv://user:password@cluster0.mongodb.net/\n</code></pre>"},{"location":"python/Connection/#connect-to-database","title":"Connect to database","text":"<pre><code>import datetime\nimport os\n\nfrom dotenv import load_dotenv\nfrom pymongo import MongoClient\n\n# Load config from a .env file:\nload_dotenv()\nMONGODB_URI = os.environ['MONGODB_URI']\n\n# Connect to your MongoDB cluster:\nclient = MongoClient(MONGODB_URI)\n</code></pre>"},{"location":"python/Connection/#list-databases","title":"List databases","text":"<pre><code># List all the databases in the cluster:\nfor db_info in client.list_database_names():\n   print(db_info)\n</code></pre>"},{"location":"python/Connection/#get-reference-to-database-and-list-its-collections","title":"Get reference to database and list its collections","text":"<pre><code># Get a reference to the 'sample_mflix' database:\ndb = client['sample_mflix']\n\n# List all the collections in 'sample_mflix':\ncollections = db.list_collection_names()\nfor collection in collections:\n   print(collection)\n</code></pre>"},{"location":"python/Delete/","title":"Delete Operations","text":""},{"location":"python/Delete/#delete_one","title":"delete_one","text":"<pre><code>document_to_delete = {\"_id\": ObjectId(\"62d6e04ecab6d8e130497485\")}\n\nresult = accounts_collection.delete_one(document_to_delete)\n\nprint(\"Documents deleted: \" + str(result.deleted_count))\n</code></pre>"},{"location":"python/Delete/#delete_many","title":"delete_many","text":"<pre><code>documents_to_delete = {\"balance\": {\"$lt\": 2000}}\n\nresult = accounts_collection.delete_many(document_to_delete)\n\nprint(\"Documents deleted: \" + str(result.deleted_count))\n</code></pre>"},{"location":"python/Find/","title":"Find Operations","text":""},{"location":"python/Find/#find_one","title":"find_one","text":"<pre><code>document_to_find = {\"_id\": ObjectId(\"62d6e04ecab6d8e1304974ae\")}\n\n# Write an expression that retrieves the document matching the query constraint in the 'accounts' collection.\nresult = accounts_collection.find_one(document_to_find)\npprint.pprint(result)\n</code></pre>"},{"location":"python/Find/#find","title":"find","text":"<pre><code># Query\ndocuments_to_find = {\"balance\": {\"$gt\": 4700}}\n\n# Write an expression that selects the documents matching the query constraint in the 'accounts' collection.\ncursor = accounts_collection.find(documents_to_find)\n\nnum_docs = 0\nfor document in cursor:\n    num_docs += 1\n    pprint.pprint(document)\nprint(\"# of documents found: \" + str(num_docs))\n</code></pre>"},{"location":"python/Insert/","title":"Insert Operations","text":""},{"location":"python/Insert/#insert_one","title":"insert_one","text":"<pre><code>new_account = {\n    \"account_holder\": \"Linus Torvalds\",\n    \"account_id\": \"MDB829001337\",\n    \"account_type\": \"checking\",\n    \"balance\": 50352434,\n    \"last_updated\": datetime.datetime.utcnow(),\n}\n\n# Write an expression that inserts the 'new_account' document into the 'accounts' collection.\nresult = accounts_collection.insert_one(new_account)\n\ndocument_id = result.inserted_id\n</code></pre>"},{"location":"python/Insert/#insert_many","title":"insert_many","text":"<pre><code>new_account = {\n    \"account_holder\": \"Linus Torvalds\",\n    \"account_id\": \"MDB829001337\",\n    \"account_type\": \"checking\",\n    \"balance\": 50352434,\n    \"last_updated\": datetime.datetime.utcnow(),\n}\n\nother_acc = {\n    \"test\":1\n}\n\n# Write an expression that inserts the 'new_account' document into the 'accounts' collection.\nresult = accounts_collection.insert_many([new_account,other_acc])\n\ndocument_ids = result.inserted_ids\nprint(f\"_ids of inserted documents: {document_ids}\")\n</code></pre>"},{"location":"python/Transactions/","title":"Transactions","text":"<ul> <li>Transactions that take longer than 60s will be cancelled</li> <li>It any operations fail the transaction won't be completed and no changes will be made</li> </ul> <pre><code># Step 1: Define the callback that specifies the sequence of operations to perform inside the transactions.\ndef callback(\n    session,\n    transfer_id=None,\n    account_id_receiver=None,\n    account_id_sender=None,\n    transfer_amount=None,\n):\n\n    # Get reference to 'accounts' collection\n    accounts_collection = session.client.bank.accounts\n\n    # Get reference to 'transfers' collection\n    transfers_collection = session.client.bank.transfers\n\n    transfer = {\n        \"transfer_id\": transfer_id,\n        \"to_account\": account_id_receiver,\n        \"from_account\": account_id_sender,\n        \"amount\": {\"$numberDecimal\": transfer_amount},\n    }\n\n    # Transaction operations\n    # Important: You must pass the session to each operation\n\n    # Update sender account: subtract transfer amount from balance and add transfer ID\n    accounts_collection.update_one(\n        {\"account_id\": account_id_sender},\n        {\n            \"$inc\": {\"balance\": -transfer_amount},\n            \"$push\": {\"transfers_complete\": transfer_id},\n        },\n        session=session,\n    )\n\n    # Update receiver account: add transfer amount to balance and add transfer ID\n    accounts_collection.update_one(\n        {\"account_id\": account_id_receiver},\n        {\n            \"$inc\": {\"balance\": transfer_amount},\n            \"$push\": {\"transfers_complete\": transfer_id},\n        },\n        session=session,\n    )\n\n    # Add new transfer to 'transfers' collection\n    transfers_collection.insert_one(transfer, session=session)\n\n    print(\"Transaction successful\")\n\n    return\n\n\ndef callback_wrapper(s):\n    callback(\n        s,\n        transfer_id=\"TR218721873\",\n        account_id_receiver=\"MDB343652528\",\n        account_id_sender=\"MDB574189300\",\n        transfer_amount=100,\n    )\n\n\n# Step 2: Start a client session\nwith client.start_session() as session:\n    # Step 3: Use with_transaction to start a transaction, execute the callback, and commit (or cancel on error)\n    session.with_transaction(callback_wrapper)\n</code></pre> <p>Using lambda expression is recommended:</p> <pre><code>with client.start_session() as session:\n    # Step 3: Use with_transaction with a lambda function\n    session.with_transaction(\n        lambda s: (\n            # Transaction operations within the lambda\n            s.client.bank.accounts.update_one(\n                {\"account_id\": account_id_sender},\n                {\n                    \"$inc\": {\"balance\": -transfer_amount},\n                    \"$push\": {\"transfers_complete\": transfer_id},\n                },\n                session=s,\n            ),\n            s.client.bank.accounts.update_one(\n                {\"account_id\": account_id_receiver},\n                {\n                    \"$inc\": {\"balance\": transfer_amount},\n                    \"$push\": {\"transfers_complete\": transfer_id},\n                },\n                session=s,\n            ),\n            s.client.bank.transfers.insert_one(\n                {\n                    \"transfer_id\": transfer_id,\n                    \"to_account\": account_id_receiver,\n                    \"from_account\": account_id_sender,\n                    \"amount\": {\"$numberDecimal\": transfer_amount},\n                },\n                session=s,\n            ),\n            print(\"Transaction successful\")\n        )\n    )\n</code></pre>"},{"location":"python/Update/","title":"Update Operations","text":""},{"location":"python/Update/#update_one","title":"update_one","text":"<pre><code># Filter\ndocument_to_update = {\"_id\": ObjectId(\"62d6e04ecab6d8e130497482\")}\n\n# Update\nadd_to_balance = {\"$inc\": {\"balance\": 100}}\n\n# Write an expression that adds to the target account balance by the specified amount.\nresult = accounts_collection.update_one(document_to_update, add_to_balance)\nprint(\"Documents updated: \" + str(result.modified_count))\n</code></pre>"},{"location":"python/Update/#update_many","title":"update_many","text":"<pre><code># Filter\nselect_accounts = {\"account_type\": \"savings\"}\n\n# Update\nset_field = {\"$set\": {\"minimum_balance\": 100}}\n\n# Write an expression that adds a 'minimum_balance' field to each savings acccount and sets its value to 100.\nresult = accounts_collection.update_many(select_accounts, set_field)\n\nprint(\"Documents matched: \" + str(result.matched_count))\nprint(\"Documents updated: \" + str(result.modified_count))\n</code></pre>"}]}